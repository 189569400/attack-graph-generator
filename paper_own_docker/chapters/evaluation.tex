
\section{EVALUATION}
\label{chap:eval}

\subsection{Use Cases}
\label{chap:heterogenious_systems}
\begin{table*}[!htb]
	\begin{center}
		\begin{tabular}{ p{20mm}p{35mm}p{35mm}p{10mm}cp{35mm} } 
			\hline
			Name & Description & Technology Stack & No. Containers & No. vuln. & GitHub link \\\hline 
			
			Netflix OSS & Combination of containers provided by Netflix. & Spring Cloud, Netflix Ribbon, Spring Cloud Netflix, Netflix's Eureka & 10 & 4111 & \url{https://github.com/Oreste-Luci/netflix-oss-example} \\
			
			Atsea Sample Shop App & An example online store application. & Spring Boot, React, NGINX, PostgreSQL & 4 & 120 & \url{https://github.com/dockersamples/atsea-sample-shop-app} \\
			
			JavaEE demo & An application for browsing movies along with other related functions. & Java EE application, React, Tomcat EE & 2 & 149 & \url{https://github.com/dockersamples/javaee-demo} \\
			
			PHPMailer and Samba & An artificial example created from two separate containers. We use an augmented version for the scalability tests. & PHPMailer(email creation and transfer class for PHP), Samba(SMB/CIFS networking protocol) & 2 & 548 &  \url{https://github.com/opsxcq/exploit-CVE-2016-10033}
			\url{https://github.com/opsxcq/exploit-CVE-2017-7494} \\
			
			
			\hline
		\end{tabular}
	\end{center}
	
	\caption{Microservice architecture examples analyzed by proposed attack graph generator}
	\label{table_technologies}
	
\end{table*}

Real-world microservice systems comprise many containers that run different technologies with various degrees of connectivity among each other. This raises the need for a robust and scalable attack graph generator. First, we demonstrate use cases in Subsection \ref{chap:heterogenious_systems}. We then examine how others have evaluated their systems. In Subsection \ref{chap:scalability_eval}, we discuss experiments conducted to test the scalability of the proposed system with different numbers of containers and varying degrees of connectivity. Note that all experiments were performed on an Intel(R) Core(TM) i5-7200U CPU (2.50GHz) with 8 GB of RAM running Ubuntu 16.04.3 LTS.

Modern microservice architectures use many different technologies,  different numbers of containers, various degrees of connectivity, and have different numbers of vulnerabilities. Therefore it is critically important to demonstrate that an attack graph generator works well in such heterogeneous scenarios. Here, we tested the proposed system on real and slightly modified GitHub examples (Table \ref{table_technologies}). We employed test examples that are publicly available to facilitate potential future comparison characterized by different system properties (e.g., topologies, technologies and vulnerabilities) and different usage domains. We also had to consider the fact that an overwhelming majority of publicly-available examples are small, i.e., only one or a few containers, which made finding appropriate test examples challenging. The resulting examples are as follows: NetflixOSS, the Atsea Sample Shop App, and the JavaEE demo. NetflixOSS is a microservice system provided by Netflix comprising of 10 containers and uses many tools, e.g., Spring Cloud, Netflix Ribbon, and Netflix Eureka. The Atsea Sample Shop App is an e-commerce sample web application comprising four containers and uses Spring Boot, React, NGINX and PostgreSQL. The JavaEE demo is a sample application for browsing movies comprising only two containers and uses JavaEE, React and Tomcat EE. We ran the attack graph generator and manually verified the resulting attack graphs for the small examples based on domain knowledge under the assumption that the output from Clair, the NVD attack vectors \cite{booth2013national}, and the preconditions and postconditions from Aksu et al. \cite{aksu2018automated} are \textit{correct}. After running the proposed attack graph generator, the attack graphs for the Atsea Sample Shop App and JavaEE demo were small as expected, containing only a few nodes and edges. The structure of the NetflixOSS attack graph demonstrated a nearly linear structure in which each node was connected to a small number of other nodes to form a chain of attacks. This linearity is due to the fact that each container is connected to only a few other containers to reduce unnecessary communication and increase encapsulation. Therefore, based on this degree of connectivity an attacker needs to perform multiple intermediate steps to reach the target container. Note that all examples terminated, there were no directed edges from containers with higher privileges to lower privileges, no duplication of nodes, and no reflexive edges were observed, which is in line with the monotonicity property. In addition, the run time of the proposed system with each example was short, however, additional scalability tests were required. Therefore, the Phpmailer and Samba system was extended and employed as an artificial example to perform scalability tests. This is discussed in the following subsection.



\subsection{Scalability evaluation}
\label{chap:scalability_eval}


\begin{table*}
	\begin{center}
		\begin{tabular}{ cccccc } 
			\hline
			Statistics & example\_20 & example\_50 & example\_100 & example\_500 & example\_1000 \\ \hline
			
			No. of Phpmailer containers & 1 & 1 & 1 & 1 & 1 \\ 
			
			No. of Samba containers & 20 & 50 & 100 & 500 & 1000 \\ 
			
			No. of nodes in topology & 23 & 53 & 103 & 503 & 1003\\ 
			
			No. of edges in topology & 253 & 1378 & 5253 & 126253 & 502503 \\ 
			
			No. nodes in attack graph & 43 & 103 & 203 & 1003 & 2003 \\ 
			
			No. edges in attack graph & 863 & 5153 & 20303 & 501503 & 2003003 \\ 
			
			Topology parsing time & 0.02879 & 0.0563 & 0.1241 & 0.7184 & 2.3664 \\ 
			
			Vulnerability preprocessing time & 0.5377 & 0.9128 & 1.6648 & 6.9961 & 15.0639 \\ 
			
			BFS time & 0.2763 & 1.6524 & 6.5527 & 165.3634 & 767.5539 \\ 
			
			Total time & 0.8429 & 2.6216 & 8.3417 & 173.0781 & 784.9843 \\ 
			\hline
		\end{tabular}
	\end{center}
	
	\caption{Scalability results with graph characteristics and execution times (s)}
	
	\label{table_scalability}
\end{table*}
Extensive study of the scalability of attack graph generators is rare in the current literature, and many parameters contribute to the complexity of comprehensive analyses. Parameters that typically vary in this sort of evaluation include the number of nodes, their connectivity and the number of vulnerabilities per container, all of which contribute to the execution time of a given algorithm. Even though the definitions of an attack graph differ, we hope to achieve a comprehensive comparison with current methods. Here, we compared the proposed system to existing work in computer networks by treating each container as a host machine and any physical connection between two machines as a connection between two containers. In the following, we first examine three methods and their scalability evaluation results. We then present the scalability results of the proposed system.

Sheyner et al. \cite{sheyner2002automated} tested their system (NuSMV) using both small and extended examples. The attack graph in the larger example has 5948 nodes and 68364 edges. The time required for NuSMV to execute this configuration was two hours; however, the model checking component took four minutes. The authors claim that the performance bottleneck resides in the graph generation procedure. Ingols et al. \cite{ingols2006practical} tested their system on a network of 250 hosts. They continued the study on a simulated network with 50000 hosts in under four minutes. Although their method yields better performance than NuSMV, their evaluation was based on a MP graph, which differs from our target graph. Ou et al. \cite{ou2006scalable} provided a more extensive study wherein they tested their system (MulVAL) using more examples. They state that the asymptotic CPU time was between $O(n^2)$ and $O(n^3)$, where n is the number of nodes (hosts). With 1000 fully-connected nodes, their system required more than 1000 seconds to execute. % The authors also provide an evaluation where he MulVAL clearly outperforms the Sheyner's system.

We used Samba \cite{samba} and Phpmailer \cite{phpmailer} containers in our scalability experiments. We extended this example and artificially created fully-connected topologies of \textit{20, 50, 100, 500, and 1000} Samba containers to test the scalability of the proposed system. As reported by Clair, the Phpmailer container has \textit{181} vulnerabilities and the Samba container has \textit{367} vulnerabilities. In our tests, we measured the total execution time and partial times, i.e., topology parsing time, vulnerability preprocessing time, and BFS time. The total time contains topology parsing, attack graph generation, and other utility processes. Here, the topology parsing time is the time required to generate the graph topology, the vulnerability preprocessing time is the time required to convert vulnerabilities into sets of preconditions and postconditions, and the BFS time is the time required for the BFS algorithm to traverse the topology and generate the attack graph after the previous steps are complete. All components were executed five times for each example and their final time was averaged. Note that the measured times are given in seconds.  However, the total time does not include the Clair vulnerability analysis, because this evaluation is beyond the scope of this analysis.

Table \ref{table_scalability} shows the experimental results. In each experiment, the number of Phpmailer containers was constant. In contrast, the number of Samba containers increased in a fully-connected manner, where a node of each container was connected to all other containers. In addition, there were also two additional artificial containers, i.e., "outside," which represents the environment from where the attacker can attack, and the "docker host," i.e., the Docker daemon where containers are hosted. Thus, the total number of nodes in the topology graph is the sum of "outside," "docker host," the number of Phpmailer containers, and the number of Samba containers. The number of edges in the topology graph is a combination of one edge ("outside"-"Phpmailer"), n edges ("docker host" to all containers) and n*(n+1)/2 edges between the Phpmailer and Samba containers. For example\_20, the number of containers is 23 (one Phpmailer container, one "outside" container, one "docker host" container, and 20 Samba containers). Thus, the number of edges in this topology graph is 253, i.e., one outside edge, 21 Docker host edges (one toward Phpmailer and 20 toward the Samba containers), and 231 between-container edges (i.e., 21*22/2=231).

Throughout the experiments, the greatest time bottleneck was the preprocessing step for the smaller configurations. However, this time increased linearly because the container files are analyzed only once by Clair. Note that the attack graph generation time for the smaller examples was considerably less than the preprocessing time. For example\_500, we note a sharp increase in execution time (165 seconds) compared to the previous example (i.e., example\_100), where the attack graph was generated in 6.5 seconds.

The total time of the attack graph generation procedure for 1000 fully-connected hosts (784 seconds) was better than the results of Ou et al. \cite{ou2006scalable}, i.e., 1000 seconds. In Sheyners's extended example (four hosts, eight atomic attacks and multiple vulnerabilities), the attack graph took two hours to create. In contrast, even for a greater number of hosts (1000), the proposed attack graph procedure demonstrates faster attack graph generation time. However, the proposed system performs worse than the generator proposed by Ingols et al., but that is attributed to the usage of the MP attack graph, which differs from our target graph. 

In summary, we found that the proposed algorithm generates attack graphs efficiently, i.e., it handles a system with 1000 containers in 13 minutes. Considering the strongly-connected system employed in the experiment and the high number of vulnerabilities in it, we consider that the results demonstrate that the proposed system is a practical solution that can be used as part of the continuous delivery processes of real-world systems. 